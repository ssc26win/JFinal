package com.shangsc.platform.model;

import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.Page;
import com.shangsc.platform.code.DictCode;
import com.shangsc.platform.code.YesOrNo;
import com.shangsc.platform.core.model.Condition;
import com.shangsc.platform.core.model.Operators;
import com.shangsc.platform.core.util.CommonUtils;
import com.shangsc.platform.core.view.InvokeResult;
import com.shangsc.platform.model.base.BaseWell;
import com.shangsc.platform.util.CodeNumUtil;
import org.apache.commons.lang3.StringUtils;

import java.math.BigDecimal;
import java.util.*;

/**
 * Generated by JFinal.
 */
@SuppressWarnings("serial")
public class Well extends BaseWell<Well> {

	public static final Well me = new Well();

	public Page<Well> getWellPage(int page, int rows, String keyword, String orderbyStr) {
		String select = "select tw.*,tc.name as companyName,tc.water_unit,tc.county,tc.street";
		StringBuffer sqlExceptSelect = new StringBuffer(" from t_well tw, t_company tc");
		sqlExceptSelect.append(" where 1=1 and tw.inner_code=tc.inner_code ");
		if (StringUtils.isNotEmpty(keyword)) {
			keyword = StringUtils.trim(keyword);
			if (StringUtils.isNotEmpty(keyword)) {
				sqlExceptSelect.append(" and (tw.name like '%" + keyword + "%' " +" or tc.name like '%" + keyword + "%'"
						+ " or tw.inner_code='" + keyword + "' or tw.well_num='" + keyword + "') ");
			}
		}
		if (StringUtils.isNotEmpty(orderbyStr)) {
			sqlExceptSelect.append(orderbyStr);
		}
		this.paginate(page, rows, select, sqlExceptSelect.toString());
		return this.paginate(page, rows, select, sqlExceptSelect.toString());
	}
	/**
	 * 水表编号是否已存在
	 * @param wellNum
	 * @return
	 */
	public boolean hasExist(String wellNum){
		Set<Condition> conditions = new HashSet<Condition>();
		conditions.add(new Condition("well_num", Operators.EQ, wellNum));
		long num = this.getCount(conditions);
		return num>0?true:false;
	}

	public InvokeResult save(Long id, String innerCode,	String name, String wellNum,
							 String village, String address, BigDecimal wellDepth, BigDecimal groundDepth, String year, Integer oneselfWell,
							 BigDecimal innerDiameter, String material,	String application,	Integer electromechanics, Integer calculateWater,
							 String pumpModel, Integer calculateType, Integer aboveScale, Integer geomorphicType, Integer groundType,
							 String nameCode, String watersType, String useEfficiency, String method, Integer licence,
							 String licenceCode, BigDecimal waterWithdrawals) {
		if (!Company.me.hasExistCompany(innerCode)) {
			return InvokeResult.failure("公司编号不存在");
		}
		if (null != id && id > 0l) {
			Well well = this.findById(id);
			if (well == null) {
				return InvokeResult.failure("更新失败, 该水井不存在");
			}
			well = setProp(well, innerCode, name, wellNum, village, address, wellDepth, groundDepth, year, oneselfWell,
					innerDiameter, material, application, electromechanics, calculateWater, pumpModel, calculateType, aboveScale, geomorphicType,
					groundType,	nameCode, watersType, useEfficiency, method, licence, licenceCode, waterWithdrawals);
			well.update();
		} else {
			if (this.hasExist(wellNum)) {
				return InvokeResult.failure("水井编号已存在");
			} else {
				Well well = new Well();
				well = setProp(well, innerCode, name, wellNum, village, address, wellDepth, groundDepth, year, oneselfWell,
						innerDiameter, material, application, electromechanics, calculateWater, pumpModel, calculateType, aboveScale, geomorphicType,
						groundType,	nameCode, watersType, useEfficiency, method, licence, licenceCode, waterWithdrawals);
				well.save();
				Company.me.updateWellNum(innerCode, true);
			}
		}
		return InvokeResult.success();
	}

	private Well setProp(Well well, String innerCode, String name, String wellNum,
			String village, String address, BigDecimal wellDepth, BigDecimal groundDepth, String year, Integer oneselfWell,
			BigDecimal innerDiameter, String material,	String application,	Integer electromechanics, Integer calculateWater,
			String pumpModel, Integer calculateType, Integer aboveScale, Integer geomorphicType,Integer groundType,
			String nameCode, String watersType, String useEfficiency, String method, Integer licence,
			String licenceCode, BigDecimal waterWithdrawals) {
		well.setInnerCode(innerCode);
		well.setName(name);
		well.setWellNum(wellNum);
		well.setVillage(village);
		well.setAddress(address);
		well.setWellDepth(wellDepth);
		well.setYear(year);
		well.setGroundDepth(groundDepth);
		well.setOneselfWell(oneselfWell);
		well.setInnerDiameter(innerDiameter);
		well.setMaterial(material);
		well.setApplication(application);
		well.setElectromechanics(electromechanics);
		well.setCalculateWater(calculateWater);
		well.setPumpModel(pumpModel);
		well.setCalculateType(calculateType);
		well.setAboveScale(aboveScale);
		well.setGeomorphicType(geomorphicType);
		well.setGroundType(groundType);
		well.setNameCode(nameCode);
		well.setWatersType(watersType);
		well.setUseEfficiency(useEfficiency);
		well.setMethod(method);
		well.setLicence(licence);
		well.setLicenceCode(licenceCode);
		well.setWaterWithdrawals(waterWithdrawals);
		return well;
	}

	public InvokeResult deleteData(String idStrs) {
		List<Long> ids = CommonUtils.getLongListByStrs(idStrs);
		for (int i = 0; i < ids.size(); i++) {
            Well well = Well.me.findById(ids.get(i));
            Company.me.updateWellNum(well.getInnerCode(), false);
			this.deleteById(ids.get(i));

		}
		return InvokeResult.success();
	}

    public static int[] saveBatch(List<Well> modelOrRecordList, int batchSize) {
        String sql = "insert into t_well(well_num,name,inner_code,village,address,year,well_depth,ground_depth," +
                "oneself_well,inner_diameter,material,application,electromechanics,calculate_water," +
                "pump_model,calculate_type,above_scale,geomorphic_type,ground_type,name_code," +
                "waters_type,use_efficiency,method,licence,licence_code,water_withdrawals) " +
                "values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

        String columns = "well_num,name,inner_code,village,address,year,well_depth,ground_depth," +
                "oneself_well,inner_diameter,material,application,electromechanics,calculate_water," +
                "pump_model,calculate_type,above_scale,geomorphic_type,ground_type,name_code," +
                "waters_type,use_efficiency,method,licence,licence_code,water_withdrawals";

        int[] result = Db.batch(sql, columns, modelOrRecordList, batchSize);
        return result;
    }

    public void importData(List<Map<Integer, String>> maps) {
        List<Well> lists = new ArrayList<Well>();
        Map<String, Integer> dictCalculateType = DictData.dao.getDictNameMap(DictCode.CalculateType);
        Map<String, Integer> dictGeomorphicType = DictData.dao.getDictNameMap(DictCode.GeomorphicType);
        Map<String, Integer> dictGroundType = DictData.dao.getDictNameMap(DictCode.GroundType);
        for (int i = 0; i < maps.size(); i++) {
            Map<Integer, String> map = maps.get(i);
            Well well = new Well();
            if (StringUtils.isEmpty(map.get(0)) || hasExist(map.get(0))) {
                continue;
            }
            if (map.get(0) != null) {
                well.setWellNum(map.get(0));
            }
            if (map.get(1) != null) {
                well.setName(map.get(1));
            }
            if (map.get(2) != null) {
                well.setInnerCode(map.get(2));
                Company.me.updateWellNum(map.get(2), true);
            }
            if (map.get(7) != null) {
                well.setVillage(map.get(7));
            }
            if (map.get(8) != null) {
                well.setAddress(map.get(8));
            }
            if (map.get(9) != null) {
                well.setYear(map.get(9));
            }
            if (map.get(10) != null) {
                well.setWellDepth(CodeNumUtil.getBigDecimal(map.get(10), 2));
            }
            if (map.get(11) != null) {
                well.setGroundDepth(CodeNumUtil.getBigDecimal(map.get(11), 2));
            }
            if (map.get(12) != null && YesOrNo.YesStr.equals(map.get(12).toString())) {
                well.setOneselfWell(Integer.parseInt(YesOrNo.Yes));
            } else{
                well.setOneselfWell(Integer.parseInt(YesOrNo.No));
            }
            if (map.get(13) != null) {
                well.setInnerDiameter(CodeNumUtil.getBigDecimal(map.get(13), 2));
            }
            if (map.get(14) != null) {
                well.setMaterial(map.get(14));
            }
            if (map.get(15) != null) {
                well.setWatersType(map.get(15));
            }
            if (map.get(16) != null) {
                well.setApplication(map.get(16));
            }
            if (map.get(17) != null && YesOrNo.YesStr.equals(map.get(17).toString())) {
                well.setElectromechanics(Integer.parseInt(YesOrNo.Yes));
            } else{
                well.setElectromechanics(Integer.parseInt(YesOrNo.No));
            }
            if (map.get(18) != null && YesOrNo.YesStr.equals(map.get(18).toString())) {
                well.setCalculateWater(Integer.parseInt(YesOrNo.Yes));
            } else{
                well.setCalculateWater(Integer.parseInt(YesOrNo.No));
            }
            if (map.get(19)!=null) {
                well.setPumpModel(map.get(19));
            }
            if (map.get(20)!=null) {
                well.setCalculateType(dictCalculateType.get(map.get(20)));
            }
            if (map.get(21) != null && YesOrNo.YesStr.equals(map.get(21).toString())) {
                well.setAboveScale(Integer.parseInt(YesOrNo.Yes));
            } else{
                well.setAboveScale(Integer.parseInt(YesOrNo.No));
            }
            if (map.get(22) != null) {
                well.setGeomorphicType(dictGeomorphicType.get(map.get(22)));
            }
            if (map.get(23) != null) {
                well.setGroundType(dictGroundType.get(map.get(23)));
            }
            if (map.get(24) != null) {
                well.setNameCode(map.get(24));
            }
            if (map.get(25) != null) {
                well.setUseEfficiency(map.get(25));
            }
            if (map.get(26) != null) {
                well.setMethod(map.get(26));
            }
            if (map.get(27) != null && YesOrNo.YesStr.equals(map.get(27).toString())) {
                well.setLicence(Integer.parseInt(YesOrNo.Yes));
            } else{
                well.setLicence(Integer.parseInt(YesOrNo.No));
            }
            if (map.get(28) != null) {
                well.setLicenceCode(map.get(28));
            }
            if (map.get(29) != null) {
                well.setWaterWithdrawals(CodeNumUtil.getBigDecimal(map.get(29), 2));
            } else {
                well.setWaterWithdrawals(CodeNumUtil.getBigDecimal("0.00", 2));
            }
            lists.add(well);
        }
        saveBatch(lists, lists.size());
    }
}
