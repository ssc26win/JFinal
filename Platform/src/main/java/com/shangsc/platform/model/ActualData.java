package com.shangsc.platform.model;

import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.Page;
import com.jfinal.plugin.activerecord.Record;
import com.shangsc.platform.code.MonthCode;
import com.shangsc.platform.core.util.CommonUtils;
import com.shangsc.platform.core.util.DateUtils;
import com.shangsc.platform.core.view.InvokeResult;
import com.shangsc.platform.model.base.BaseActualData;
import com.shangsc.platform.util.ToolDateTime;
import org.apache.commons.lang3.StringUtils;

import java.math.BigDecimal;
import java.util.*;

/**
 * Generated by JFinal.
 */
@SuppressWarnings("serial")
public class ActualData extends BaseActualData<ActualData> {

	public static final ActualData me = new ActualData();//status : 正常 异常 停用

	public InvokeResult save(Long id, String innerCode, String meter_address,
							 String alarm, BigDecimal netWater, BigDecimal sumWater, Integer state, String voltage, Date writeTime) {
		if (null != id && id > 0l) {
			ActualData actualData = this.findById(id);
			if (actualData == null) {
				return InvokeResult.failure("更新失败, 该记录不存在");
			}
			actualData = setProp(actualData, innerCode, meter_address, alarm, netWater, sumWater, state, voltage, writeTime);
			actualData.update();
		} else {
			ActualData actualData = new ActualData();
			actualData = setProp(actualData, innerCode, meter_address, alarm, netWater, sumWater, state, voltage, writeTime);
			actualData.save();
		}
		return InvokeResult.success();
	}

	private ActualData setProp(ActualData actualData, String innerCode, String meter_address,
							   String alarm, BigDecimal netWater, BigDecimal sumWater, Integer state, String voltage, Date writeTime) {
		actualData.setInnerCode(innerCode);
		actualData.setMeterAddress(meter_address);
		actualData.setAlarm(alarm);
		actualData.setNetWater(netWater);
		actualData.setState(state);
        actualData.setSumWater(sumWater);
		if (writeTime == null) {
			actualData.setWriteTime(new Date());
		} else {
			actualData.setWriteTime(writeTime);
		}
		actualData.setVoltage(voltage);
		return actualData;
	}

	public InvokeResult deleteData(String idStrs) {
		List<Long> ids = CommonUtils.getLongListByStrs(idStrs);
		for (int i = 0; i < ids.size(); i++) {
			this.deleteById(ids.get(i));
		}
		return InvokeResult.success();
	}

	public Page<ActualData> getActualDataPage(int page, int rows, String keyword, String orderbyStr) {
		String select = "select tad.*,tc.name as companyName,tc.water_unit,tc.county,max(tad.write_time)";
		StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad inner join " +
				" t_company tc on tad.inner_code=tc.inner_code");
		sqlExceptSelect.append(" where 1=1");
		if (StringUtils.isNotEmpty(keyword)) {
			sqlExceptSelect.append(" and (tad.inner_code='" + StringUtils.trim(keyword) + "' or tad.meter_address='" + StringUtils.trim(keyword)
					+ "' or tc.name like '%" + StringUtils.trim(keyword) + "%') ");
		}
		String groupbyStr = " group by tad.meter_address ";
		sqlExceptSelect.append(groupbyStr);
		orderbyStr = " order by tad.write_time desc ";
		if (StringUtils.isNotEmpty(orderbyStr)) {
			sqlExceptSelect.append(orderbyStr);
		}
		this.paginate(page, rows, select, sqlExceptSelect.toString());
		return this.paginate(page, rows, select, sqlExceptSelect.toString());
	}

	public Page<ActualData> getReadnumStatis(int pageNo, int pageSize, String orderbyStr, Date startTime, Date endTime,
											 String name, String innerCode, Integer street, Integer watersType, String meterAttr) {
		String select=" select twm.*,tc.name,tc.address,tc.street,tc.water_unit,tc.county,tm.meter_attr,tm.meter_address,tm.meter_num,tm.line_num ";
		StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data twm inner join " +
				" t_company tc on twm.inner_code=tc.inner_code " +
				" inner join t_water_meter tm on twm.inner_code=tm.inner_code");
		sqlExceptSelect.append(" where 1=1 ");
		if (startTime != null) {
			sqlExceptSelect.append(" and twm.write_time >= '" + ToolDateTime.format(startTime, "yyyy-MM-dd HH:mm:ss") + "'");
		}
		if (endTime != null) {
			sqlExceptSelect.append(" and twm.write_time <= '" + ToolDateTime.format(endTime, "yyyy-MM-dd HH:mm:ss") + "'");
		}
		if (StringUtils.isNotEmpty(name)) {
			name = StringUtils.trim(name);
			if (StringUtils.isNotEmpty(name)) {
				sqlExceptSelect.append(" and tc.name like '%" + name + "%'");
			}
		}
		if (StringUtils.isNotEmpty(meterAttr)) {
			meterAttr = StringUtils.trim(meterAttr);
			if (StringUtils.isNotEmpty(meterAttr)) {
				sqlExceptSelect.append(" and tm.meter_attr like '%" + meterAttr + "%'");
			}
		}
		if (street != null && street > 0) {
			sqlExceptSelect.append(" and tc.street=" + street);
		}
		if (StringUtils.isNotEmpty(innerCode)) {
			innerCode = StringUtils.trim(innerCode);
			if (StringUtils.isNotEmpty(innerCode)) {
				sqlExceptSelect.append(" and twm.inner_code ='" + innerCode + "'");
			}
		}
		if (watersType != null) {
			sqlExceptSelect.append(" and twm.waters_type=" + watersType);
		}
		sqlExceptSelect.append(" group by twm.write_time ");
		if (StringUtils.isNotEmpty(orderbyStr)) {
			sqlExceptSelect.append(orderbyStr);
		}
		return this.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
	}

	public Page<ActualData> getDailyStatis(int pageNo, int pageSize, String orderbyStr, Date startTime, Date endTime,
										   String name, String innerCode, Integer street, Integer watersType, String meterAttr) {
		String select=" select twm.*,tc.name,tc.address,tc.water_unit,tc.county,tm.meter_attr,tm.meter_address,tm.meter_num,tm.line_num ";
		StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data twm inner join " +
				" t_company tc on twm.inner_code=tc.inner_code " +
				" inner join t_water_meter tm on twm.inner_code=tm.inner_code");
		sqlExceptSelect.append(" where 1=1 ");
		if (startTime != null) {
			sqlExceptSelect.append(" and twm.write_time >= '" + ToolDateTime.format(startTime, "yyyy-MM-dd HH:mm:ss") + "'");
		}
		if (endTime != null) {
			sqlExceptSelect.append(" and twm.write_time <= '" + ToolDateTime.format(endTime, "yyyy-MM-dd HH:mm:ss")  + "'");
		}
		if (StringUtils.isNotEmpty(name)) {
			name = StringUtils.trim(name);
			if (StringUtils.isNotEmpty(name)) {
				sqlExceptSelect.append(" and tc.name like '%" + name + "%'");
			}
		}
		if (StringUtils.isNotEmpty(meterAttr)) {
			meterAttr = StringUtils.trim(meterAttr);
			if (StringUtils.isNotEmpty(meterAttr)) {
				sqlExceptSelect.append(" and tm.meter_attr like '%" + meterAttr + "%'");
			}
		}
		if (street != null && street > 0) {
			sqlExceptSelect.append(" and tc.street=" + street);
		}
		if (StringUtils.isNotEmpty(innerCode)) {
			innerCode = StringUtils.trim(innerCode);
			if (StringUtils.isNotEmpty(innerCode)) {
				sqlExceptSelect.append(" and twm.inner_code ='" + innerCode + "'");
			}
		}
		if (watersType != null) {
			sqlExceptSelect.append(" and twm.waters_type=" + watersType);
		}
		sqlExceptSelect.append(" group by twm.inner_code ");
		if (StringUtils.isNotEmpty(orderbyStr)) {
			sqlExceptSelect.append(orderbyStr);
		}
		return this.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
	}

	public Page<ActualData> getMonthStatis(int pageNo, int pageSize, String orderbyStr, Date startTime, Date endTime,
										   String name, String innerCode, Integer street, Integer watersType, String meterAttr) {
		String select=" select twm.*,tc.name,tc.address,tc.water_unit,tc.county,sum(net_water) as netWaterNum,tm.billing_cycle," +
				"tm.meter_num,tm.meter_attr,tm.meter_address,tm.line_num";
		StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data twm inner join " +
				" t_company tc on twm.inner_code=tc.inner_code " +
				" inner join t_water_meter tm on twm.inner_code=tm.inner_code");
		sqlExceptSelect.append(" where 1=1 ");
		if (startTime != null) {
			sqlExceptSelect.append(" and twm.write_time >= '" + ToolDateTime.format(startTime, "yyyy-MM-dd HH:mm:ss") + "'");
		}
		if (endTime != null) {
			sqlExceptSelect.append(" and twm.write_time <= '" +  ToolDateTime.format(endTime, "yyyy-MM-dd HH:mm:ss") + "'");
		}
		if (StringUtils.isNotEmpty(name)) {
			name = StringUtils.trim(name);
			if (StringUtils.isNotEmpty(name)) {
				sqlExceptSelect.append(" and tc.name like '%" + name + "%'");
			}
		}
		if (StringUtils.isNotEmpty(meterAttr)) {
			meterAttr = StringUtils.trim(meterAttr);
			if (StringUtils.isNotEmpty(meterAttr)) {
				sqlExceptSelect.append(" and tm.meter_attr like '%" + meterAttr + "%'");
			}
		}
		if (street != null && street > 0) {
			sqlExceptSelect.append(" and tc.street=" + street);
		}
		if (StringUtils.isNotEmpty(innerCode)) {
			innerCode = StringUtils.trim(innerCode);
			if (StringUtils.isNotEmpty(innerCode)) {
				sqlExceptSelect.append(" and twm.inner_code ='" + innerCode + "'");
			}
		}
		if (watersType != null) {
			sqlExceptSelect.append(" and twm.waters_type=" + watersType);
		}
		sqlExceptSelect.append(" group by twm.inner_code ");
		if (StringUtils.isNotEmpty(orderbyStr)) {
			sqlExceptSelect.append(orderbyStr);
		}
		return this.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
	}

	public Page<ActualData> getYearStatis(int pageNo, int pageSize, String orderbyStr, Integer year,
										  String name, String innerCode, Integer street, Integer watersType, String meterAttr) {
		String select=" select twm.*,tc.name,tc.address,tc.water_unit,tc.county,sum(net_water) as netWaterNum," +
				"tm.meter_attr,tm.meter_num,tm.meter_address,tm.line_num";
		StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data twm inner join " +
				" t_company tc on twm.inner_code=tc.inner_code " +
				" inner join t_water_meter tm on twm.inner_code=tm.inner_code");
		sqlExceptSelect.append(" where 1=1 ");
		if (year != null && year > 0) {
			String yearStart = DateUtils.formatDate(DateUtils.getStrDate(String.valueOf(year) + "-01-01 00:00:00"));
			String yearEnd = DateUtils.formatDate(DateUtils.getStrDate(String.valueOf(year) + "-12-31 23:59:59"));
			sqlExceptSelect.append(" and twm.write_time >= '" +  yearStart + "'");
			sqlExceptSelect.append(" and twm.write_time <= '" +  yearEnd + "'");
		}
		if (StringUtils.isNotEmpty(name)) {
			name = StringUtils.trim(name);
			if (StringUtils.isNotEmpty(name)) {
				sqlExceptSelect.append(" and tc.name like '%" + name + "%'");
			}
		}
		if (StringUtils.isNotEmpty(meterAttr)) {
			meterAttr = StringUtils.trim(meterAttr);
			if (StringUtils.isNotEmpty(meterAttr)) {
				sqlExceptSelect.append(" and tm.meter_attr like '%" + meterAttr + "%'");
			}
		}
		if (street != null && street > 0) {
			sqlExceptSelect.append(" and tc.street=" + street);
		}
		if (StringUtils.isNotEmpty(innerCode)) {
			innerCode = StringUtils.trim(innerCode);
			if (StringUtils.isNotEmpty(innerCode)) {
				sqlExceptSelect.append(" and twm.inner_code ='" + innerCode + "'");
			}
		}
		if (watersType != null) {
			sqlExceptSelect.append(" and twm.waters_type=" + watersType);
		}
		sqlExceptSelect.append(" group by twm.inner_code ");
		if (StringUtils.isNotEmpty(orderbyStr)) {
			sqlExceptSelect.append(orderbyStr);
		}
		return this.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
	}

	public List<Record> getTodayActualDataPage() {
		Date date = new Date();
		String nowBefore = ToolDateTime.getYesterdayStr(date);
		String now = ToolDateTime.getDateStr(date);
		StringBuffer sqlExceptSelect = new StringBuffer("select t.* from t_actual_data t where 1=1");
		sqlExceptSelect.append(" and t.write_time >='" + nowBefore + "'");
		sqlExceptSelect.append(" and t.write_time <='" + now + "'");
		sqlExceptSelect.append(" GROUP BY t.meter_address");
		return Db.find(sqlExceptSelect.toString());
	}

	public List<Record> getMonthActualDataPage(String inner_code ) {
		String select = "select sum(t.net_water) as total ,date_format(t.write_time, '%m') as time ,t.* from t_actual_data t ";
		StringBuffer sqlExceptSelect = new StringBuffer();
		sqlExceptSelect.append(select);
		sqlExceptSelect.append(" where t.inner_code='"+inner_code+"'");
		sqlExceptSelect.append(" group by date_format(write_time, '%m')");
		return Db.find(sqlExceptSelect.toString());
	}

	//select * from `ht_invoice_information` where YEAR(create_date)=YEAR(NOW());
	//net_water
	public Record getYearActual(String inner_code) {
		String select = "select sum(net_water) as yearTotal from t_actual_data where YEAR(write_time)=YEAR(NOW()) and inner_code="+inner_code;
		return Db.find(select).get(0);
	}

	public List<Record> getDailyActualData( ) {
		String sql = "select  sum(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m-%d') as DAY,t.* from t_actual_data t GROUP BY  date_format(t.write_time, '%Y-%m-%d')";

		return Db.find(sql);
	}

	public List<Record> getMonthActualData( ) {
		String sql = "select  sum(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m') as month,t.* from t_actual_data t GROUP BY  date_format(t.write_time, '%Y-%m')";

		return Db.find(sql);
	}

	public ActualData getLastMeterAddress(String meter_address) {
		return ActualData.me.findFirst("select t.* from t_actual_data t where 1=1 and t.meter_address='" + meter_address + "' order by t.write_time desc limit 1");
	}

	private String normalMeterConditionSql(){
		Date date = new Date();
		String nowBefore = ToolDateTime.getYesterdayStr(date);
		String now = ToolDateTime.getDateStr(date);
		StringBuffer exceptionMeterSql = new StringBuffer("select t.* from t_actual_data t where 1=1");
		exceptionMeterSql.append(" and t.write_time >='" + nowBefore + "'");
		exceptionMeterSql.append(" and t.write_time <='" + now + "'");
		exceptionMeterSql.append(" GROUP BY t.meter_address");
		return exceptionMeterSql.toString();
	}

	public Set<String> getNormalAddress() {
		Set<String> address = new HashSet<>();
		String normalMeterSql = normalMeterConditionSql();
		List<ActualData> datas = this.find(normalMeterSql);
		for (ActualData actualData:datas) {
			address.add(actualData.getMeterAddress());
		}
		return address;
	}

	public Set<String> getMapWarnInnerCode(Date date) {
		Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(date);
        String start = monthDateBetween.get("start");
        String end = monthDateBetween.get("end");
        String month_str = monthDateBetween.get("month_str");
        Integer month = Integer.parseInt(monthDateBetween.get("month"));
        String sql = "select * from (select allad.*,sum(allad.net_water) as sumWater from (select tad.*,twm.waters_type from t_actual_data tad inner join (select waters_type,meter_address from t_water_meter) twm" +
				"on twm.meter_address=tad.meter_address) allad where allad.write_time >='"+start+"' and allad.write_time <'"+end+"' group by allad.meter_address) t" +
				"INNER join t_water_index twi on twi.inner_code=t.inner_code where t.sumWater>twi." + month_str + " and t.waters_type=twi.waters_type";
        List<Record> records = Db.find(sql);
        Set<String> set = new HashSet<>();
        for (Record record:records) {
            set.add(record.get("inner_code").toString());
        }
        return set;
	}

    public static void main(String[] args) {
        Map<Integer, String> map = MonthCode.getMap();
        Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(new Date());
        String start = monthDateBetween.get("start");
        String end = monthDateBetween.get("end");
        String month_str = monthDateBetween.get("month_str");
        Integer month = Integer.parseInt(monthDateBetween.get("month"));

        System.out.println(start + end + month_str +month);
    }
}
