package com.shangsc.platform.model;

import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.Page;
import com.jfinal.plugin.activerecord.Record;
import com.shangsc.platform.code.MonthCode;
import com.shangsc.platform.model.base.BaseActualData;
import com.shangsc.platform.util.ToolDateTime;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * Generated by JFinal.
 */
@SuppressWarnings("serial")
public class ActualDataWx extends BaseActualData<ActualDataWx> {

    public static final ActualDataWx me = new ActualDataWx();
    public final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**********************************
     * WxApp use
     ***************************************/

    public Page<ActualData> finWxActualDataByStatus(int page, int rows, String keyword, String wxInnerCode, String status, int exceptionTime) {
        String select = "select * ";
        StringBuffer sqlExceptSelect = new StringBuffer("from (" +
                "select al.*," +
                "(case" +
                "  when (unix_timestamp(NOW())-unix_timestamp(al.write_time))>" + 3600 * exceptionTime + " then 1" +
                "  when net_water<=0 then 2" +
                "  else 0" +
                "  end) as stats" +
                " from " +
                "(select tad.*,tc.name as companyName,tc.real_code,tc.water_unit,tc.county,twm.line_num,twm.waters_type from " +
                "(select * from t_actual_data order by write_time desc)  tad " +
                "left join  t_company tc on tad.inner_code=tc.inner_code " +
                "left join t_water_meter twm on tad.meter_address=twm.meter_address where 1=1 group by tad.meter_address) al) alld ");
        sqlExceptSelect.append(" where 1=1 ");
        if (StringUtils.isNotEmpty(status)) {
            sqlExceptSelect.append(" and alld.stats = " + status);
        }
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (alld.inner_code='" + StringUtils.trim(keyword) + "' or alld.meter_address='" + StringUtils.trim(keyword)
                    + "' or alld.companyName like '%" + StringUtils.trim(keyword) + "%') ");
        }
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and alld.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        sqlExceptSelect.append(" group by alld.meter_address ");
        return ActualData.me.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Page<ActualData> finWxActualData(int page, int rows, String keyword, String wxInnerCode) {
        String select = "select * ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from (" +
                "select tad.*,tc.name as companyName,tc.real_code,tc.water_unit,tc.county,twm.line_num,twm.waters_type   from (select * from t_actual_data order by write_time desc)  tad " +
                "left join  t_company tc on tad.inner_code=tc.inner_code " +
                "left join t_water_meter twm on tad.meter_address=twm.meter_address where 1=1 group by tad.meter_address " +
                "union all (SELECT tad.id,tc.inner_code,tm.meter_address,tad.alarm,tad.net_water,tad.sum_water,tad.state," +
                "tad.write_time,tad.voltage,companyName,tc.real_code,tc.water_unit,tc.county,tm.line_num,tm.waters_type FROM t_water_meter tm " +
                "left join (select name as companyName,water_unit,county,inner_code,real_code from t_company) tc on tm.inner_code=tc.inner_code " +
                "left join t_actual_data tad on tad.meter_address=tm.meter_address " +
                "where tm.meter_address not in (select meter_address from t_actual_data))) alld");
        sqlExceptSelect.append(" where 1=1");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (alld.inner_code='" + StringUtils.trim(keyword) + "' or alld.meter_address='" + StringUtils.trim(keyword)
                    + "' or alld.companyName like '%" + StringUtils.trim(keyword) + "%') ");
        }
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and alld.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        return ActualData.me.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public List<Record> findWxActualChart(String wxInnerCode, String meterAddress) {
        Map<String, String> map = ToolDateTime.getBefore30DateTime();
        String start = map.get(MonthCode.warn_start_date);
        String end = map.get(MonthCode.warn_end_date);
        String sql = "select abs(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m-%d') as DAY,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                " and t.write_time >= '" + start + "' " +
                " and t.write_time <= '" + end + "' " +
                " GROUP BY date_format(t.write_time, '%Y-%m-%d')";
        return Db.find(sql);
    }

    public List<Record> getWxDailyActualData(String wxInnerCode, String startTime, String endTime) {
        Map<String, String> map = ToolDateTime.getBefore30DateTime();
        String start = map.get(MonthCode.warn_start_date);
        String end = map.get(MonthCode.warn_end_date);
        String sql = "select sum(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m-%d') as DAY,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                (StringUtils.isNotEmpty(startTime) ? " and t.write_time >= '" + startTime + "'" : " and t.write_time >= '" + start + "' ") +
                (StringUtils.isNotEmpty(endTime) ? " and t.write_time <= '" + endTime + "'" : " and t.write_time <= '" + end + "' ") +
                " GROUP BY date_format(t.write_time, '%Y-%m-%d')";
        return Db.find(sql);
    }

    public List<Record> getWxMonthActualData(String wxInnerCode, String startTime, String endTime) {
        Map<String, String> map = ToolDateTime.getBefore12MonthDateTime();
        String start = map.get(MonthCode.warn_start_date);
        String end = map.get(MonthCode.warn_end_date);
        String sql = "select  sum(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m') as month,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                (StringUtils.isNotEmpty(startTime) ? " and t.write_time >= '" + startTime + "'" : " and t.write_time >= '" + start + "' ") +
                (StringUtils.isNotEmpty(endTime) ? " and t.write_time <= '" + endTime + "'" : " and t.write_time <= '" + end + "' ") +
                " GROUP BY date_format(t.write_time, '%Y-%m')";
        return Db.find(sql);
    }

    public List<Record> getWxYearActualData(String wxInnerCode, String startTime, String endTime) {
        String sql = "select sum(t.net_water) as sumWater,date_format(t.write_time, '%Y') as year,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                (StringUtils.isNotEmpty(startTime) ? " and t.write_time >= '" + startTime + "'" : " ") +
                (StringUtils.isNotEmpty(endTime) ? " and t.write_time <= '" + endTime + "'" : " ") +
                " GROUP BY date_format(t.write_time, '%Y')";
        return Db.find(sql);
    }

    public Page<ActualData> findWxDailyList(int pageNo, int pageSize, String startTime, String endTime, String keyword, String wxInnerCode) {
        String select = " select abs(tad.net_water) as absNetWater,tc.name,tc.real_code,tc.inner_code,tc.address,tc.water_unit," +
                "tc.county,tc.company_type," +
                "date_format(tad.write_time, '%Y-%m-%d') as todays ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad " +
                " inner join t_company  tc on tad.inner_code=tc.inner_code " +
                " inner join t_water_meter twm on tad.meter_address=twm.meter_address " +
                " where 1=1 ");
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and tc.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        if (StringUtils.isNotEmpty(startTime)) {
            sqlExceptSelect.append(" and tad.write_time >= '" + startTime + "' ");
        }
        if (StringUtils.isNotEmpty(endTime)) {
            sqlExceptSelect.append(" and tad.write_time <= '" + endTime + "' ");
        }
        sqlExceptSelect.append(" group by tad.inner_code,date_format(tad.write_time, '%Y-%m-%d') ");
        sqlExceptSelect.append(" order by date_format(tad.write_time, '%Y-%m-%d') desc ");
        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

    public Page<ActualData> findWxMonthList(int pageNo, int pageSize, String startTime, String endTime, String keyword, String wxInnerCode) {

        String select = " select tc.inner_code,tc.name,tc.real_code,tc.address,tc.water_unit,tc.county,tc.company_type," +
                /*"twm.waters_type,twm.meter_attr,twm.meter_num,twm.line_num,twm.meter_address," +*/
                "date_format(tad.write_time, '%Y-%m') as months,sum(abs(tad.net_water)) as monthTotal";

        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad " +
                " inner join t_company tc on tad.inner_code=tc.inner_code " +
                " inner join t_water_meter twm on tad.meter_address=twm.meter_address " +
                " where 1=1 ");
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and tc.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }

        if (StringUtils.isNotEmpty(startTime)) {
            sqlExceptSelect.append(" and tad.write_time >= '" + startTime + "'");
        }
        if (StringUtils.isNotEmpty(endTime)) {
            sqlExceptSelect.append(" and tad.write_time <= '" + endTime + "'");
        }
        sqlExceptSelect.append(" group by tad.inner_code,date_format(tad.write_time, '%Y-%m') ");
        sqlExceptSelect.append(" order by date_format(tad.write_time, '%Y-%m') desc ");

        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

    public Page<ActualData> findWxYearList(int pageNo, int pageSize, String startTime, String endTime, String keyword, String wxInnerCode) {
        String select = " select tc.inner_code,tc.name,tc.real_code,tc.address,tc.water_unit,tc.county,tc.company_type, " +
                /*" twm.waters_type,twm.meter_attr,twm.meter_num,twm.line_num,twm.meter_address, " +*/
                " date_format(tad.write_time, '%Y') as years,sum(abs(tad.net_water)) as yearTotal ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad " +
                " inner join t_company tc on tad.inner_code=tc.inner_code " +
                " inner join t_water_meter twm on tad.meter_address=twm.meter_address " +
                " where 1=1 ");
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and tc.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }

        if (StringUtils.isNotEmpty(startTime)) {
            sqlExceptSelect.append(" and tad.write_time >= '" + startTime + "'");
        }
        if (endTime != null) {
            sqlExceptSelect.append(" and tad.write_time <= '" + endTime + "'");
        }
        sqlExceptSelect.append(" group by tad.inner_code,date_format(tad.write_time, '%Y') ");
        sqlExceptSelect.append("order by date_format(tad.write_time, '%Y') desc");

        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

    public List<Record> getWxMeterDailyActualData(String wxInnerCode, String meterAddress, String startTime, String endTime) {
        Map<String, String> map = ToolDateTime.getBefore30DateTime();
        String start = map.get(MonthCode.warn_start_date);
        String end = map.get(MonthCode.warn_end_date);
        String sql = "select sum(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m-%d') as DAY,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                (StringUtils.isNotEmpty(meterAddress) ? " and t.meter_address = '" + meterAddress + "'" : " ") +
                (StringUtils.isNotEmpty(startTime) ? " and t.write_time >= '" + startTime + "'" : " and t.write_time >= '" + start + "' ") +
                (StringUtils.isNotEmpty(endTime) ? " and t.write_time <= '" + endTime + "'" : " and t.write_time <= '" + end + "' ") +
                " GROUP BY date_format(t.write_time, '%Y-%m-%d')";
        return Db.find(sql);
    }

    public List<Record> getWxMeterMonthActualData(String wxInnerCode, String meterAddress, String startTime, String endTime) {
        Map<String, String> map = ToolDateTime.getBefore12MonthDateTime();
        String start = map.get(MonthCode.warn_start_date);
        String end = map.get(MonthCode.warn_end_date);
        String sql = "select  sum(t.net_water) as sumWater,date_format(t.write_time, '%Y-%m') as month,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                (StringUtils.isNotEmpty(meterAddress) ? " and t.meter_address = '" + meterAddress + "'" : " ") +
                (StringUtils.isNotEmpty(startTime) ? " and t.write_time >= '" + startTime + "'" : " and t.write_time >= '" + start + "' ") +
                (StringUtils.isNotEmpty(endTime) ? " and t.write_time <= '" + endTime + "'" : " and t.write_time <= '" + end + "' ") +
                " GROUP BY date_format(t.write_time, '%Y-%m')";
        return Db.find(sql);
    }

    public List<Record> getWxMeterYearActualData(String wxInnerCode, String meterAddress, String startTime, String endTime) {
        String sql = "select sum(t.net_water) as sumWater,date_format(t.write_time, '%Y') as year,t.* from t_actual_data t" +
                " where " + (StringUtils.isNotEmpty(wxInnerCode) ? " t.inner_code in (" + wxInnerCode + ") " : " 1=1 ") +
                (StringUtils.isNotEmpty(meterAddress) ? " and t.meter_address = '" + meterAddress + "'" : " ") +
                (StringUtils.isNotEmpty(startTime) ? " and t.write_time >= '" + startTime + "'" : " ") +
                (StringUtils.isNotEmpty(endTime) ? " and t.write_time <= '" + endTime + "'" : " ") +
                " GROUP BY date_format(t.write_time, '%Y')";
        return Db.find(sql);
    }

    public Page<ActualData> findWxMeterDailyList(int pageNo, int pageSize, String startTime, String endTime, String keyword, String wxInnerCode, String meterAddress) {
        String select = " select abs(tad.net_water) as absNetWater,tc.name,tc.real_code,tc.inner_code,tc.address,tc.water_unit," +
                "tc.county,tc.company_type," +
                "date_format(tad.write_time, '%Y-%m-%d') as todays ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad " +
                " inner join t_company  tc on tad.inner_code=tc.inner_code " +
                " inner join t_water_meter twm on tad.meter_address=twm.meter_address " +
                " where 1=1 ");
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and tc.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        if (StringUtils.isNotEmpty(meterAddress)) {
            sqlExceptSelect.append(" and tad.meter_address ='" + meterAddress + "'");
        }
        if (StringUtils.isNotEmpty(startTime)) {
            sqlExceptSelect.append(" and tad.write_time >= '" + startTime + "' ");
        }
        if (StringUtils.isNotEmpty(endTime)) {
            sqlExceptSelect.append(" and tad.write_time <= '" + endTime + "' ");
        }
        sqlExceptSelect.append(" group by tad.inner_code,date_format(tad.write_time, '%Y-%m-%d') ");
        sqlExceptSelect.append(" order by date_format(tad.write_time, '%Y-%m-%d') desc ");
        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

    public Page<ActualData> findWxMeterMonthList(int pageNo, int pageSize, String startTime, String endTime, String keyword, String wxInnerCode, String meterAddress) {

        String select = " select tc.inner_code,tc.name,tc.real_code,tc.address,tc.water_unit,tc.county,tc.company_type," +
                /*"twm.waters_type,twm.meter_attr,twm.meter_num,twm.line_num,twm.meter_address," +*/
                "date_format(tad.write_time, '%Y-%m') as months,sum(abs(tad.net_water)) as monthTotal";

        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad " +
                " inner join t_company tc on tad.inner_code=tc.inner_code " +
                " inner join t_water_meter twm on tad.meter_address=twm.meter_address " +
                " where 1=1 ");
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and tc.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        if (StringUtils.isNotEmpty(meterAddress)) {
            sqlExceptSelect.append(" and tad.meter_address ='" + meterAddress + "'");
        }

        if (StringUtils.isNotEmpty(startTime)) {
            sqlExceptSelect.append(" and tad.write_time >= '" + startTime + "'");
        }
        if (StringUtils.isNotEmpty(endTime)) {
            sqlExceptSelect.append(" and tad.write_time <= '" + endTime + "'");
        }
        sqlExceptSelect.append(" group by tad.inner_code,date_format(tad.write_time, '%Y-%m') ");
        sqlExceptSelect.append(" order by date_format(tad.write_time, '%Y-%m') desc ");

        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

    public Page<ActualData> findWxMeterYearList(int pageNo, int pageSize, String startTime, String endTime, String keyword, String wxInnerCode, String meterAddress) {
        String select = " select tc.inner_code,tc.name,tc.real_code,tc.address,tc.water_unit,tc.county,tc.company_type, " +
                /*" twm.waters_type,twm.meter_attr,twm.meter_num,twm.line_num,twm.meter_address, " +*/
                " date_format(tad.write_time, '%Y') as years,sum(abs(tad.net_water)) as yearTotal ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data tad " +
                " inner join t_company tc on tad.inner_code=tc.inner_code " +
                " inner join t_water_meter twm on tad.meter_address=twm.meter_address " +
                " where 1=1 ");
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and tc.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        if (StringUtils.isNotEmpty(meterAddress)) {
            sqlExceptSelect.append(" and tad.meter_address ='" + meterAddress + "'");
        }

        if (StringUtils.isNotEmpty(startTime)) {
            sqlExceptSelect.append(" and tad.write_time >= '" + startTime + "'");
        }
        if (StringUtils.isNotEmpty(endTime)) {
            sqlExceptSelect.append(" and tad.write_time <= '" + endTime + "'");
        }
        sqlExceptSelect.append(" group by tad.inner_code,date_format(tad.write_time, '%Y') ");
        sqlExceptSelect.append("order by date_format(tad.write_time, '%Y') desc");

        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

    public Page<ActualData> findWxReadSearchList(int pageNo, int pageSize, Date startTime, Date endTime, String keyword, String wxInnerCode) {
        String select = " select twm.*,tc.name,tc.real_code,tc.address,tc.street,tc.water_unit,tc.county,tc.company_type,tm.waters_type,tm.meter_attr," +
                "tm.meter_address,tm.meter_num,tm.line_num ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_actual_data twm inner join " +
                " t_company tc on twm.inner_code=tc.inner_code " +
                " left join t_water_meter tm on twm.meter_address=tm.meter_address");
        sqlExceptSelect.append(" where 1=1 ");
        if (startTime != null) {
            sqlExceptSelect.append(" and twm.write_time >= '" + ToolDateTime.format(startTime, "yyyy-MM-dd HH:mm:ss") + "'");
        }
        if (endTime != null) {
            sqlExceptSelect.append(" and twm.write_time <= '" + ToolDateTime.format(endTime, "yyyy-MM-dd HH:mm:ss") + "'");
        }
        if (StringUtils.isNotEmpty(wxInnerCode)) {
            sqlExceptSelect.append(" and twm.inner_code in (" + StringUtils.trim(wxInnerCode) + ") ");
        }
        sqlExceptSelect.append(" group by twm.write_time ");
        sqlExceptSelect.append(" order by twm.write_time desc ");

        return ActualData.me.paginate(pageNo, pageSize, select, sqlExceptSelect.toString());
    }

}
