package com.shangsc.platform.model;

import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.Page;
import com.jfinal.plugin.activerecord.Record;
import com.shangsc.platform.code.CompanyType;
import com.shangsc.platform.code.DictCode;
import com.shangsc.platform.code.MonthCode;
import com.shangsc.platform.core.model.Condition;
import com.shangsc.platform.core.model.Operators;
import com.shangsc.platform.core.util.CommonUtils;
import com.shangsc.platform.core.util.DateUtils;
import com.shangsc.platform.core.view.InvokeResult;
import com.shangsc.platform.model.base.BaseCompany;
import com.shangsc.platform.util.CodeNumUtil;
import com.shangsc.platform.util.ToolDateTime;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

import java.math.BigDecimal;
import java.util.*;

/**
 * Generated by JFinal.
 */
@SuppressWarnings("serial")
public class Company extends BaseCompany<Company> {
    public static final Company me = new Company();
    private static final long serialVersionUID = -1982696969221258167L;

    public String globalInnerCode;

    public void setGlobalInnerCode(String globalInnerCode) {
        this.globalInnerCode = globalInnerCode;
    }

    public boolean hasExistCompany(String inner_code) {
        Set<Condition> conditions = new HashSet<Condition>();
        conditions.add(new Condition("inner_code", Operators.EQ, inner_code));
        long num = Company.me.getCount(conditions);
        return num > 0 ? true : false;
    }

    public boolean hasExistByRealCode(String realCode) {
        Set<Condition> conditions = new HashSet<Condition>();
        conditions.add(new Condition("real_code", Operators.EQ, realCode));
        long num = Company.me.getCount(conditions);
        return num > 0 ? true : false;
    }

    public Company findByRealCode(String realCode) {
        String sql = "select * from t_company where real_code='" + realCode + "'";
        List<Company> companies = this.find(sql);
        if (CollectionUtils.isNotEmpty(companies)) {
            return companies.get(0);
        }
        return null;
    }

    public Company findByInnerCode(String inner_code) {
        String sql = "select * from t_company where inner_code='" + inner_code + "'";
        List<Company> companies = this.find(sql);
        if (CollectionUtils.isNotEmpty(companies)) {
            return companies.get(0);
        }
        return null;
    }

    public boolean hasExistInnerCode(Long id, String innerCode) {
        StringBuffer sqlSelect = new StringBuffer("select count(1) as existCount from t_company where 1=1 ");
        sqlSelect.append(" and inner_code='" + innerCode + "'");
        if (id != null) {
            sqlSelect.append(" and id<>" + id + "");
        }
        Record record = Db.findFirst(sqlSelect.toString());
        if (record != null) {
            return record.getLong("existCount") == 1L;
        } else {
            return false;
        }
    }

    public void updateMeterNum(String innerCode, boolean flag) {
        Company company = Company.me.findByInnerCode(innerCode);
        if (company != null) {
            Integer num = company.getRemotemeterCount();
            if (num == null) {
                num = 0;
            }
            if (flag) {
                company.setRemotemeterCount(num + 1);
            } else {
                if (num > 0) {
                    company.setRemotemeterCount(num - 1);
                }
            }
            company.update();
        }
    }

    public void updateWellNum(String innerCode, boolean flag) {
        Company company = Company.me.findByInnerCode(innerCode);
        if (company != null) {
            Integer num = company.getWellCount();
            if (num == null) {
                num = 0;
            }
            if (flag) {
                company.setWellCount(num + 1);
            } else {
                if (num > 0) {
                    company.setWellCount(num - 1);
                }
            }
            company.update();
        }
    }

    public boolean hasExistName(Long id, String name) {
        StringBuffer sqlSelect = new StringBuffer("select count(1) as existCount from t_company where 1=1 ");
        sqlSelect.append(" and name='" + name + "'");
        if (id != null) {
            sqlSelect.append(" and id<>" + id + "");
        }
        Record record = Db.findFirst(sqlSelect.toString());
        if (record != null) {
            return record.getLong("existCount") == 1L;
        } else {
            return false;
        }
    }

    public boolean hasExistRealCode(Long id, String realCode) {
        StringBuffer sqlSelect = new StringBuffer("select count(1) as existCount from t_company where 1=1 ");
        sqlSelect.append(" and real_code='" + realCode + "'");
        if (id != null) {
            sqlSelect.append(" and id<>" + id + "");
        }
        Record record = Db.findFirst(sqlSelect.toString());
        if (record != null) {
            return record.getLong("existCount") == 1L;
        } else {
            return false;
        }
    }

    public InvokeResult deleteData(String idStrs) {
        List<Long> ids = CommonUtils.getLongListByStrs(idStrs);
        for (int i = 0; i < ids.size(); i++) {
            this.deleteById(ids.get(i));
        }
        return InvokeResult.success();
    }

    public InvokeResult save(Long id, String name, String realCode, String innerCode, String waterUnit, String county, Integer street, String streetSrc,
                             String address, Integer customerType, Integer waterUseType, String gbIndustry, String mainIndustry,
                             String contact, String phone, String postalCode, String department, Integer wellCount, Integer firstWatermeterCount,
                             Integer remotemeterCount, Integer unitType, BigDecimal longitude, BigDecimal latitude, Date createTime,
                             BigDecimal self_well_price, BigDecimal surface_price, BigDecimal self_free_price, Integer company_type, String memo, Integer term) {
        if (hasExistRealCode(id, realCode)) {
            return InvokeResult.failure("保存失败，单位编号已存在");
        }

        if (hasExistName(id, name)) {
            return InvokeResult.failure("保存失败，单位名称已存在");
        }

        if (null != id && id > 0L) {
            Company company = this.findById(id);
            if (company == null) {
                return InvokeResult.failure("更新失败单位, 该单位不存在");
            }
            company = setProp(company, name, realCode, innerCode, waterUnit, county, street, streetSrc, address, customerType, waterUseType,
                    gbIndustry, mainIndustry, contact, phone, postalCode, department, wellCount, firstWatermeterCount,
                    remotemeterCount, unitType, longitude, latitude, createTime, self_well_price, surface_price,
                    self_free_price, company_type, memo, term);
            company.update();
        } else {
            Company company = new Company();
            company = setProp(company, name, realCode, innerCode, waterUnit, county, street, streetSrc, address, customerType, waterUseType,
                    gbIndustry, mainIndustry, contact, phone, postalCode, department, wellCount, firstWatermeterCount,
                    remotemeterCount, unitType, longitude, latitude, createTime, self_well_price, surface_price,
                    self_free_price, company_type, memo, term);
            company.save();
        }
        return InvokeResult.success();
    }

    private Company setProp(Company company, String name, String realCode, String innerCode, String waterUnit, String county, Integer street, String streetSrc,
                            String address, Integer customerType, Integer waterUseType, String gbIndustry, String mainIndustry,
                            String contact, String phone, String postalCode, String department, Integer wellCount, Integer firstWatermeterCount,
                            Integer remotemeterCount, Integer unitType, BigDecimal longitude, BigDecimal latitude, Date createTime,
                            BigDecimal self_well_price, BigDecimal surface_price, BigDecimal self_free_price, Integer company_type, String memo, Integer term) {
        company.setName(name);
        company.setRealCode(realCode);
        company.setInnerCode(innerCode);
        company.setWaterUnit(waterUnit);
        company.setCounty(county);
        company.setStreet(street);
        company.setStreetSrc(streetSrc);
        company.setAddress(address);
        company.setCustomerType(customerType);
        company.setWaterUseType(waterUseType);
        company.setGbIndustry(gbIndustry);
        company.setMainIndustry(mainIndustry);
        company.setContact(contact);
        company.setPhone(phone);
        company.setPostalCode(postalCode);
        company.setDepartment(department);
        company.setWellCount(wellCount);
        company.setFirstWatermeterCount(firstWatermeterCount);
        company.setRemotemeterCount(remotemeterCount);
        company.setUnitType(unitType);
        company.setLongitude(longitude);
        company.setLatitude(latitude);
        company.setCompanyType(company_type);
        if (createTime == null) {
            company.setCreateTime(new Date());
        } else {
            company.setCreateTime(createTime);
        }
        company.setSelfWellPrice(self_well_price);
        company.setSurfacePrice(surface_price);
        company.setSelfFreePrice(self_free_price);
        company.setMemo(memo);
        company.setTerm(term);
        return company;
    }

    public Page<Company> getCompanyPage(int page, int rows, String keyword, String orderbyStr, String companyType, Integer term) {
        String select = "select c.*, (select count(net_water) from t_actual_data tad where c.inner_code = tad.inner_code) as waterUseNum";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c ");
        sqlExceptSelect.append(" where 1=1 ");
        if (term != null) {
            sqlExceptSelect.append("and c.term=" + term);
        }
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(companyType)) {
            sqlExceptSelect.append(" and company_type=" + companyType);
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public List<Record> getCompanyAll(String innerCode) {
        String select = "select * from t_company c left join (select sum(net_water) as waterUseNum,inner_code as innerCode from t_actual_data GROUP BY inner_code) tad" +
                " on c.inner_code=tad.innerCode where 1=1 ";
        if (StringUtils.isNotEmpty(innerCode)) {
            select = select + " and c.inner_code='" + innerCode + "'";
        }
        if (StringUtils.isNotEmpty(globalInnerCode)) {
            select = select + " and c.inner_code='" + globalInnerCode + "'";
        }
        return Db.find(select);
    }

    public List<Record> getCompanyByType(String type) {
        String select = "select * from t_company c left join (select sum(net_water) as waterUseNum,inner_code as innerCode from t_actual_data GROUP BY inner_code) tad" +
                " on c.inner_code=tad.innerCode";
        if ("1".equals(type)) {
            String innerCodes = getWarnInnerCodes();
            select = select + " where c.inner_code not in (" + innerCodes + ")";
        } else if ("2".equals(type)) {
            String innerCodes = getWarnInnerCodes();
            select = select + " where c.inner_code in (" + innerCodes + ")";
        } else {
            select = select + " where 1=1 ";
        }
        return Db.find(select);
    }

    @Deprecated
    public Map<String, Object> getCompanyMap() {
        List<Company> allList = this.getAllList();
        Map<String, Object> map = new HashMap<String, Object>();
        for (Company company : allList) {
            map.put(company.getInnerCode(), company.getName());
        }
        return map;
    }

    public int hasActual() {
        String sqlExceptSelect = " select count(c.inner_code) as normalNum from t_company c " +
                "INNER JOIN (select DISTINCT inner_code from t_actual_data) ta on ta.inner_code=c.inner_code";
        List<Record> lists = Db.find(sqlExceptSelect);
        if (CollectionUtils.isNotEmpty(lists)) {
            Object obj = lists.get(0).get("normalNum");
            if (obj != null) {
                return Integer.parseInt(obj.toString());
            } else {
                return 0;
            }
        }
        return 0;
    }

    public int totalCount() {
        String sqlExceptSelect = " select count(*) as totalCompany from (select DISTINCT inner_code from t_company) c ";
        List<Record> lists = Db.find(sqlExceptSelect);
        if (CollectionUtils.isNotEmpty(lists)) {
            Object obj = lists.get(0).get("totalCompany");
            if (obj != null) {
                return Integer.parseInt(obj.toString());
            } else {
                return 0;
            }
        }
        return 0;
    }

    @Deprecated
    public int warnCount() {
        String innerCodes = getWarnInnerCodes();
        String sqlExceptSelect = " select count(*) as warnCompany from t_company" +
                " where inner_code in (" + innerCodes + ")";
        List<Record> lists = Db.find(sqlExceptSelect);
        if (CollectionUtils.isNotEmpty(lists)) {
            Object obj = lists.get(0).get("warnCompany");
            if (obj != null) {
                return Integer.parseInt(obj.toString());
            } else {
                return 0;
            }
        }
        return 0;
    }

    public Page<Company> getWarnCompanyPage(int page, int rows, String keyword, String orderbyStr) {
        Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(new Date());
        String select = "select c.*";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c ");
        sqlExceptSelect.append(" where company_type=1 ");
        sqlExceptSelect.append(" and inner_code in (" + getWarnExceptionInnerCodeSql(monthDateBetween) + ")");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Page<Company> getAlarmCompany(int page, int rows, String keyword, String orderbyStr) {
        Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(new Date());
        //String start = monthDateBetween.get(MonthCode.warn_start_date);
        //String end = monthDateBetween.get(MonthCode.warn_end_date);

        //Integer month = Integer.parseInt(monthDateBetween.get(MonthCode.warn_month));
        String month_str = monthDateBetween.get((MonthCode.warn_month_str));

        //Integer month_target = Integer.parseInt(monthDateBetween.get(MonthCode.warn_target_month));
        String month_target_str = monthDateBetween.get(MonthCode.warn_target_month_str);

        String select = "select c.*";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c ");
        sqlExceptSelect.append(" inner join (select " + month_str + "," + month_target_str + " from t_water_index) twi on twi.inner_code=c.inner_code ");

        sqlExceptSelect.append(" where company_type=1 ");
        sqlExceptSelect.append(" and inner_code in (" + getWarnExceptionInnerCodeSql(monthDateBetween) + ")");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Page<Company> getAlarmCompanyPage(int page, int rows, String keyword, String orderbyStr, Map<String, String> monthDateBetween) {
        /**
         select * from (select allad.*,sum(allad.net_water) as sumWater from (select tad.inner_code,tad.net_water,tad.meter_address,tad.write_time,twm.waters_type from t_actual_data tad
         inner join (select waters_type,meter_address from t_water_meter) twm on twm.meter_address=tad.meter_address) allad
         where allad.write_time >='2018-03-01 00:00:00' and allad.write_time <'2018-03-02 23:59:59' group by allad.inner_code) t

         inner join (select march,april,inner_code,waters_type from t_water_index) twi on twi.inner_code=t.inner_code
         inner join (select name,inner_code,address,water_unit,county,company_type from t_company) tc on tc.inner_code=t.inner_code
         where  t.waters_type=twi.waters_type
         */
        String start = monthDateBetween.get(MonthCode.warn_start_date);
        String end = monthDateBetween.get(MonthCode.warn_end_date);
        String select = "select * ";
        StringBuffer sqlExceptSelect = new StringBuffer(" from (select allad.*,sum(allad.net_water) as sumWater from " +
                " (select tad.inner_code,tad.net_water,tad.meter_address,tad.write_time,twm.waters_type from t_actual_data tad " +
                " inner join (select waters_type,meter_address from t_water_meter) twm on twm.meter_address=tad.meter_address) allad ");
        sqlExceptSelect.append(" where allad.write_time >='" + start + "' and allad.write_time <'" + end + "' group by allad.inner_code) t");
        sqlExceptSelect.append(" inner join (select " + StringUtils.join(MonthCode.monthStrList(), ",")
                + ",inner_code,waters_type from t_water_index) twi on twi.inner_code=t.inner_code ");

        sqlExceptSelect.append(" inner join (select name,inner_code,address,water_unit,county,company_type from t_company) tc on tc.inner_code=t.inner_code ");
        sqlExceptSelect.append(" where t.waters_type=twi.waters_type ");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (name like '%" + StringUtils.trim(keyword) + "%' or inner_code='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Page<Company> getNormalCompanyPage(int page, int rows, String keyword, String orderbyStr) {
        Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(new Date());
        String select = "select c.*";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c ");
        sqlExceptSelect.append(" where company_type=1");
        sqlExceptSelect.append(" and inner_code not in (" + getWarnExceptionInnerCodeSql(monthDateBetween) + ")");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Page<Company> getOtherCompanyPage(int page, int rows, String keyword, String orderbyStr) {
        String select = "select c.*";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c");
        sqlExceptSelect.append(" where company_type=1 and c.inner_code not in (select DISTINCT inner_code from t_actual_data tad )");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Page<Company> getSupplyCompanyPage(int page, int rows, String keyword, String orderbyStr) {
        String select = "select c.*";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c");
        sqlExceptSelect.append(" where company_type=2 ");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(orderbyStr)) {
            sqlExceptSelect.append(orderbyStr);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }

    public Integer getSupplyCompanyCount() {
        return Integer.parseInt(this.find("select count(*) as sumCount from t_company where company_type=2").get(0).get("sumCount").toString());
    }


    private Set<String> warnInnerCodes = new HashSet<>();
    // 预警閥值
    private static final BigDecimal THRESHOLD = new BigDecimal("2");

    @Deprecated
    public String getWarnInnerCodes() {
        //用水量告警单位数量
        //取得用水指标数据
        List<WaterIndex> waterIndices = WaterIndex.me.getAllList();
        for (WaterIndex index : waterIndices) {
            index.getWaterIndex();//年
            WaterMeter waterMeter = WaterMeter.me.findByInnerCode(index.getInnerCode());

            if (null != waterMeter) {
                Record records1 = ActualData.me.getYearActual(index.getInnerCode());
                if (null != records1) {
                    comp((BigDecimal) records1.get("yearTotal"), (BigDecimal) index.getWaterIndex(), index.getInnerCode());

                    List<Record> records = ActualData.me.getMonthActualDataPage(index.getInnerCode());
                    for (int i = 0; i < records.size(); i++) {
                        Record record = records.get(i);
                        BigDecimal monthActTotal = new BigDecimal(record.get("total").toString());
                        switch ((record.get("time").toString())) {
                            case "01":
                                comp(monthActTotal, index.getJanuary(), index.getInnerCode());
                                break;
                            case "02":
                                comp(monthActTotal, index.getFebruary(), index.getInnerCode());
                                break;
                            case "03":
                                comp(monthActTotal, index.getMarch(), index.getInnerCode());
                                break;
                            case "04":
                                comp(monthActTotal, index.getApril(), index.getInnerCode());
                                break;
                            case "05":
                                comp(monthActTotal, index.getMay(), index.getInnerCode());
                                break;
                            case "06":
                                comp(monthActTotal, index.getJune(), index.getInnerCode());
                                break;
                            case "07":
                                comp(monthActTotal, index.getJuly(), index.getInnerCode());
                                break;
                            case "08":
                                comp(monthActTotal, index.getAugust(), index.getInnerCode());
                                break;
                            case "09":
                                comp(monthActTotal, index.getSeptember(), index.getInnerCode());
                                break;
                            case "10":
                                comp(monthActTotal, index.getOctober(), index.getInnerCode());
                                break;
                            case "11":
                                comp(monthActTotal, index.getNovember(), index.getInnerCode());
                                break;
                            case "12":
                                comp(monthActTotal, index.getDecember(), index.getInnerCode());
                                break;
                        }
                    }
                }
            }

        }
        String innerCodes = "";
        StringBuilder sb = new StringBuilder();
        for (String innerCode : warnInnerCodes) {
            sb.append("'").append(innerCode).append("'").append(",");
        }
        if (StringUtils.isNotEmpty(sb.toString())) {
            innerCodes = sb.toString().substring(0, sb.toString().length() - 1);
        }
        return innerCodes;
    }

    public String getWarnExceptionInnerCodeSql(Map<String, String> monthDateBetween) {
        String start = monthDateBetween.get("start");
        String end = monthDateBetween.get("end");
        String month_str = monthDateBetween.get("month_str");
        Integer month = Integer.parseInt(monthDateBetween.get("month"));
        String sql = "select t.inner_code from (select allad.*,sum(allad.net_water) as sumWater from (select tad.*,twm.waters_type from t_actual_data tad inner join (select waters_type,meter_address from t_water_meter) twm" +
                " on twm.meter_address=tad.meter_address) allad where allad.write_time >='" + start + "' and allad.write_time <'" + end + "' group by allad.meter_address) t" +
                " INNER join t_water_index twi on twi.inner_code=t.inner_code where t.sumWater>twi." + month_str + " and t.waters_type=twi.waters_type";
        return sql;
    }

    public String getWarnExceptionSql(Date date) {
        Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(date);
        String start = monthDateBetween.get("start");
        String end = monthDateBetween.get("end");
        String month_str = monthDateBetween.get("month_str");
        Integer month = Integer.parseInt(monthDateBetween.get("month"));
        String sql = "select * from (select allad.*,sum(allad.net_water) as sumWater from (select tad.*,twm.waters_type from t_actual_data tad inner join (select waters_type,meter_address from t_water_meter) twm" +
                " on twm.meter_address=tad.meter_address) allad where allad.write_time >='" + start + "' and allad.write_time <'" + end + "' group by allad.meter_address) t" +
                " INNER join t_water_index twi on twi.inner_code=t.inner_code where t.sumWater>twi." + month_str + " and t.waters_type=twi.waters_type";
        return sql;
    }

    public Set<String> getWarnExceptionInnerCode(Date date) {
        Map<String, String> monthDateBetween = ToolDateTime.get2MonthDateBetween(date);
        String start = monthDateBetween.get(MonthCode.warn_start_date);
        String end = monthDateBetween.get(MonthCode.warn_end_date);
        String month_str = monthDateBetween.get(MonthCode.warn_month_str);
        Integer month = Integer.parseInt(monthDateBetween.get(MonthCode.warn_month));
        String sql = "select * from (select allad.*,sum(allad.net_water) as sumWater from (select tad.*,twm.waters_type from t_actual_data tad inner join (select waters_type,meter_address from t_water_meter) twm" +
                " on twm.meter_address=tad.meter_address) allad where allad.write_time >='" + start + "' and allad.write_time <'" + end + "' group by allad.meter_address) t" +
                " INNER join t_water_index twi on twi.inner_code=t.inner_code left join t_company c on c.inner_code=t.inner_code " +
                "where t.sumWater>twi." + month_str + " and t.waters_type=twi.waters_type";
        List<Record> records = Db.find(sql);
        Set<String> set = new HashSet<>();
        for (Record record : records) {
            set.add(record.get("inner_code").toString());
        }
        return set;
    }

    private void comp(BigDecimal monthActTotal, BigDecimal moth, String innerCode) {
        if (null == moth) {
            moth = new BigDecimal(0);
        }
        if (moth.add(THRESHOLD).compareTo(monthActTotal) < 0) {
            warnInnerCodes.add(innerCode);
        }
    }

    public static int[] saveBatch(List<Company> modelOrRecordList, int batchSize) {
        String sql = "insert into t_company(inner_code,real_code,name,water_unit,county,street,street_src,address,customer_type,gb_industry," +
                "main_industry,water_use_type,contact,phone,postal_code,department,well_count,first_watermeter_count," +
                "remotemeter_count,unit_type,longitude,latitude,self_well_price,surface_price,self_free_price,create_time,company_type,term,memo)" +
                " values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
        String columns = "inner_code,real_code,name,water_unit,county,street,street_src,address,customer_type,gb_industry," +
                "main_industry,water_use_type,contact,phone,postal_code,department,well_count,first_watermeter_count," +
                "remotemeter_count,unit_type,longitude,latitude,self_well_price,surface_price,self_free_price,create_time,company_type,term,memo";
        int[] result = Db.batch(sql, columns, modelOrRecordList, batchSize);
        return result;
    }

    public void importData(List<Map<Integer, String>> maps) {
        List<Company> lists = new ArrayList<Company>();
        Map<String, Integer> dictUserType = DictData.dao.getDictNameMap(DictCode.UserType);
        Map<String, Integer> dictStreet = DictData.dao.getDictNameMap(DictCode.Street);
        Map<String, Integer> dictWaterUseType = DictData.dao.getDictNameMap(DictCode.WaterUseType);
        Map<String, Integer> termType = DictData.dao.getDictNameMap(DictCode.Term);
        Set<String> checkRepeat = new HashSet<>();
        for (int i = 0; i < maps.size(); i++) {
            Company company = new Company();
            Integer company_type = CompanyType.COMPANY;
            Map<Integer, String> map = maps.get(i);
            String realCode = null;
            if (StringUtils.isNotEmpty(map.get(0))) {
                realCode = map.get(0).toString();
            }
            //String innerCode = CodeNumUtil.genInnerCode();
            String innerCode = realCode;

            if (StringUtils.isEmpty(realCode) || hasExistByRealCode(realCode) || checkRepeat.contains(realCode)) {
                continue;
            } else {
                checkRepeat.add(realCode);
            }
            String name = null;
            if (StringUtils.isNotEmpty(map.get(1))) {
                name = map.get(1).toString();
                if (CompanyType.notCompany(name)) {
                    company_type = CompanyType.SUPPLY;
                }
            }
            String waterUnit = null;
            if (StringUtils.isNotEmpty(map.get(2))) {
                waterUnit = map.get(2).toString();
            }
            String county = null;
            if (StringUtils.isNotEmpty(map.get(3))) {
                county = map.get(3).toString();
            }
            Integer street = null;
            if (StringUtils.isNotEmpty(map.get(4))) {
                street = dictStreet.get(map.get(4).toString());
            }
            String streetSrc = null;
            if (StringUtils.isNotEmpty(map.get(5))) {
                streetSrc = map.get(5).toString();
            }
            Integer customerType = null;
            if (StringUtils.isNotEmpty(map.get(6))) {
                customerType = dictUserType.get(map.get(6).toString());
                if (CompanyType.notCompany(name)) {
                    company_type = CompanyType.SUPPLY;
                }
            }
            String gbIndustry = null;
            if (StringUtils.isNotEmpty(map.get(7))) {
                gbIndustry = map.get(7).toString();
            }
            // 单位编号	单位名称	所属节水办	所属区县	所属乡镇	原乡镇或街道	用户类型	国标行业	主要行业
            // 取水用途	联系人	联系电话	单位地址	邮政编码	管水部门	自备井基本水价	地表水基本水价
            // 自来水基本水价	注册日期
            String mainIndustry = null;
            if (StringUtils.isNotEmpty(map.get(8))) {
                mainIndustry = map.get(8).toString();
            }
            Integer waterUseType = null;
            if (StringUtils.isNotEmpty(map.get(9))) {
                waterUseType = dictWaterUseType.get(map.get(9).toString());
            }
            String contact = null;
            if (StringUtils.isNotEmpty(map.get(10))) {
                contact = map.get(10).toString();
            }
            String phone = null;
            if (StringUtils.isNotEmpty(map.get(11))) {
                phone = map.get(11).toString();
            }
            String address = null;
            if (StringUtils.isNotEmpty(map.get(12))) {
                address = map.get(12).toString();
            }
            String postalCode = null;
            if (StringUtils.isNotEmpty(map.get(13))) {
                postalCode = map.get(13).toString();
            }
            String department = null;
            if (StringUtils.isNotEmpty(map.get(14))) {
                department = map.get(14).toString();
            }
            Integer wellCount = 0;
            Integer firstWatermeterCount = 0;
            Integer remotemeterCount = 0;
            Integer unitType = 1;
            BigDecimal self_well_price = null;
            if (StringUtils.isNotEmpty(map.get(15))) {
                self_well_price = CodeNumUtil.getBigDecimal(map.get(15).toString(), 2);
            }
            BigDecimal surface_price = null;
            if (StringUtils.isNotEmpty(map.get(16))) {
                surface_price = CodeNumUtil.getBigDecimal(map.get(16).toString(), 2);
            }
            BigDecimal self_free_price = null;
            if (StringUtils.isNotEmpty(map.get(17))) {
                self_free_price = CodeNumUtil.getBigDecimal(map.get(17).toString(), 2);
            }
            Date createDate = null;
            Object createDateObj = map.get(18);
            if (createDateObj != null) {
                String createDateStr = createDateObj.toString();
                String date = "";
                if (createDateStr.indexOf("-") > 0) {
                    date = ToolDateTime.format(StringUtils.trim(createDateStr) + " 00:00:00", ToolDateTime.pattern_ymd, ToolDateTime.pattern_ymd_hms);
                } else if (createDateStr.indexOf("/") > 0) {
                    date = ToolDateTime.format(StringUtils.trim(createDateStr) + " 00:00:00", ToolDateTime.pattern_ymd2, ToolDateTime.pattern_ymd_hms);
                } else {
                    date = ToolDateTime.format(new Date(), ToolDateTime.pattern_ymd_hms);
                }
                createDate = DateUtils.getDate(date, ToolDateTime.pattern_ymd);
            }
            Integer term = 1;//默认1
            if (StringUtils.isNotEmpty(map.get(19))) {
                term = termType.get(map.get(19).toString());
            }
            String memo = null;
            if (StringUtils.isNotEmpty(map.get(20))) {
                memo = map.get(20).toString();
            }
            setProp(company, name, realCode, innerCode, waterUnit, county, street, streetSrc, address, customerType, waterUseType,
                    gbIndustry, mainIndustry, contact, phone, postalCode, department, wellCount, firstWatermeterCount,
                    remotemeterCount, unitType, null, null, createDate, self_well_price, surface_price, self_free_price,
                    company_type, memo, term);
            lists.add(company);
        }
        saveBatch(lists, lists.size());
    }

    public Map<String, String> loadNameList() {
        String sql = "select name,inner_code from t_company";
        List<Company> companies = this.find(sql);
        Map<String, String> names = new HashMap<>();
        for (Company company : companies) {
            names.put(company.getName(), company.getInnerCode());
        }
        return names;
    }

    public Map<String, String> searchNameList(String name) {
        String sql = "select name,inner_code from t_company where name like '%" + name + "%'";
        List<Company> companies = this.find(sql);
        Map<String, String> names = new HashMap<>();
        for (Company company : companies) {
            names.put(company.getName(), company.getInnerCode());
        }
        return names;
    }

    public Map<Integer, Object> getTermGroup() {
        List<Record> records = Db.find("select term,count(term) as termTotal from t_company group by term");
        Map<Integer, Object> result = new LinkedHashMap<>();
        for (Record record : records) {
            result.put(record.getInt("term"), record.get("termTotal"));
        }
        return result;
    }

    /*********************************** WxApp use ***************************************/

    public Page<Company> findWxList(int page, int rows, String keyword, String companyType) {
        String select = "select c.*, (select count(net_water) from t_actual_data tad where c.inner_code = tad.inner_code) as waterUseNum";
        StringBuffer sqlExceptSelect = new StringBuffer(" from t_company c ");
        sqlExceptSelect.append(" where 1=1 ");
        if (StringUtils.isNotEmpty(keyword)) {
            sqlExceptSelect.append(" and (c.name like '%" + StringUtils.trim(keyword) + "%' or c.inner_code='" + StringUtils.trim(keyword)
                    + "' or contact='" + StringUtils.trim(keyword) + "') ");
        }
        if (StringUtils.isNotEmpty(companyType)) {
            sqlExceptSelect.append(" and company_type=" + companyType);
        }
        return this.paginate(page, rows, select, sqlExceptSelect.toString());
    }
}
